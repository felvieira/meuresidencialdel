// This file is automatically generated. Do not edit it directly.
import { createClient } from '@supabase/supabase-js';
import type { Database } from './types';

const SUPABASE_URL = "https://kcbvdcacgbwigefwacrk.supabase.co";
const SUPABASE_PUBLISHABLE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImtjYnZkY2FjZ2J3aWdlZndhY3JrIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDIyMjgzMDQsImV4cCI6MjA1NzgwNDMwNH0.K4xcW6V3X9QROQLekB74NbKg3BaShwgMbanrP3olCYI";

// Import the supabase client like this:
// import { supabase } from "@/integrations/supabase/client";

export const supabase = createClient<Database>(SUPABASE_URL, SUPABASE_PUBLISHABLE_KEY);

// Function to get condominium data by matricula
export const getCondominiumByMatricula = async (matricula: string) => {
  const { data, error } = await supabase
    .from('condominiums')
    .select('*')
    .eq('matricula', matricula)
    .single();
  
  if (error) {
    console.error('Error fetching condominium data:', error);
    return null;
  }
  
  return data;
};

// Function to save condominium data
export const saveCondominiumData = async (formData: any, userEmail: string | null) => {
  const { matricula } = formData;
  
  // Check if record exists
  const { data: existingRecord } = await supabase
    .from('condominiums')
    .select('*')
    .eq('matricula', matricula)
    .single();
  
  let result;
  
  if (existingRecord) {
    // If record exists, update it and log changes
    const { data, error } = await supabase
      .from('condominiums')
      .update(formData)
      .eq('matricula', matricula)
      .select();
    
    if (error) {
      console.error('Error updating condominium:', error);
      throw error;
    }
    
    // Log changes for each field
    for (const key in formData) {
      if (existingRecord[key] !== formData[key] && key !== 'confirmarSenha') {
        await supabase.from('condominium_change_logs').insert({
          matricula,
          campo: key,
          valor_anterior: existingRecord[key]?.toString() || null,
          valor_novo: formData[key]?.toString() || null,
          usuario: userEmail
        });
      }
    }
    
    result = data;
  } else {
    // If record doesn't exist, insert it
    const { data, error } = await supabase
      .from('condominiums')
      .insert(formData)
      .select();
    
    if (error) {
      console.error('Error creating condominium:', error);
      throw error;
    }
    
    result = data;
  }
  
  return result;
};

// Function to get condominium change logs
export const getCondominiumChangeLogs = async (matricula: string) => {
  const { data, error } = await supabase
    .from('condominium_change_logs')
    .select('*')
    .eq('matricula', matricula)
    .order('data_alteracao', { ascending: false });
  
  if (error) {
    console.error('Error fetching change logs:', error);
    throw error;
  }
  
  return data;
};

// Common Areas functions
export const getCommonAreas = async (matricula: string) => {
  try {
    const { data, error } = await supabase
      .from('common_areas')
      .select('*')
      .eq('matricula', matricula)
      .order('name');
    
    if (error) {
      console.error('Error fetching common areas:', error);
      throw error;
    }
    
    return data;
  } catch (error) {
    console.error('Error in getCommonAreas:', error);
    throw error;
  }
};

export const getCommonAreaById = async (id: string) => {
  try {
    const { data, error } = await supabase
      .from('common_areas')
      .select('*')
      .eq('id', id)
      .single();
    
    if (error) {
      console.error('Error fetching common area:', error);
      return null;
    }
    
    return data;
  } catch (error) {
    console.error('Error in getCommonAreaById:', error);
    return null;
  }
};

export const getReservationsByCommonAreaId = async (commonAreaId: string) => {
  try {
    const { data, error } = await supabase
      .from('common_area_reservations')
      .select(`
        *,
        residents:resident_id (nome_completo, unidade)
      `)
      .eq('common_area_id', commonAreaId)
      .order('reservation_date', { ascending: false });
    
    if (error) {
      console.error('Error fetching reservations:', error);
      throw error;
    }
    
    return data || [];
  } catch (error) {
    console.error('Error in getReservationsByCommonAreaId:', error);
    throw error;
  }
};

// Announcement functions with type assertions to avoid TypeScript errors
export const getAnnouncements = async (matricula: string) => {
  try {
    // Use type assertion to bypass TypeScript checking
    const { data, error } = await (supabase
      .from('announcements' as any)
      .select('*')
      .eq('matricula', matricula)
      .order('created_at', { ascending: false }) as any);
    
    if (error) {
      console.error('Error fetching announcements:', error);
      throw error;
    }
    
    return data;
  } catch (error) {
    console.error('Error in getAnnouncements:', error);
    throw error;
  }
};

export const getAnnouncementById = async (id: string) => {
  try {
    // Use type assertion to bypass TypeScript checking
    const { data, error } = await (supabase
      .from('announcements' as any)
      .select('*')
      .eq('id', id)
      .single() as any);
    
    if (error) {
      console.error('Error fetching announcement:', error);
      return null;
    }
    
    return data;
  } catch (error) {
    console.error('Error in getAnnouncementById:', error);
    return null;
  }
};

export const saveAnnouncement = async (announcementData: any) => {
  try {
    const { id } = announcementData;
    
    if (id) {
      // Update existing announcement
      // Use type assertion to bypass TypeScript checking
      const { data, error } = await (supabase
        .from('announcements' as any)
        .update({
          ...announcementData,
          updated_at: new Date().toISOString()
        })
        .eq('id', id)
        .select() as any);
      
      if (error) {
        console.error('Error updating announcement:', error);
        throw error;
      }
      
      return data;
    } else {
      // Create new announcement
      // Use type assertion to bypass TypeScript checking
      const { data, error } = await (supabase
        .from('announcements' as any)
        .insert({
          ...announcementData,
          created_at: new Date().toISOString()
        })
        .select() as any);
      
      if (error) {
        console.error('Error creating announcement:', error);
        throw error;
      }
      
      return data;
    }
  } catch (error) {
    console.error('Error in saveAnnouncement:', error);
    throw error;
  }
};

export const deleteAnnouncement = async (id: string) => {
  try {
    // Use type assertion to bypass TypeScript checking
    const { error } = await (supabase
      .from('announcements' as any)
      .delete()
      .eq('id', id) as any);
    
    if (error) {
      console.error('Error deleting announcement:', error);
      throw error;
    }
    
    return true;
  } catch (error) {
    console.error('Error in deleteAnnouncement:', error);
    throw error;
  }
};
